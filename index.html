<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Motley Crews</title>
<style>
  /* Layout + theme */
  * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: linear-gradient(135deg,#1a202c 0%,#2d3748 100%);
    color: #e2e8f0;
    min-height: 100vh;
    padding: 12px;
  }
  .container { max-width: 1200px; margin: 0 auto; }

  .header { text-align:center; padding: 14px 0; background: rgba(0,0,0,0.25); border-radius: 10px; margin-bottom: 12px; }
  h1 { font-size: 20px; }

  .game-info { display:flex; justify-content:space-between; gap:12px; align-items:center;
    padding:10px 12px; background: rgba(0,0,0,0.18); border-radius:8px; margin-bottom: 10px; font-size:14px; }

  .turn-indicator { padding:8px 12px; border-radius:18px; font-weight:700; text-align:center; }
  .turn-player-a { background:#3182ce; color:white; }
  .turn-player-b { background:#e53e3e; color:white; }

  /* Board scaling: base cell ~50px * 1.8 = 90px */
  .board-container { display:flex; justify-content:center; margin: 10px 0; }
  .board {
    display: grid;
    grid-template-columns: repeat(8, 90px);
    grid-template-rows: repeat(8, 90px);
    gap: 2px;
    background: #2d3748;
    padding: 6px;
    border-radius: 10px;
    box-shadow: 0 6px 20px rgba(0,0,0,0.4);
  }

  .cell {
    width: 90px;
    height: 90px;
    background: #4a5568;
    border-radius: 6px;
    border: 1px solid #2d3748;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size: 28px;
    font-weight:700;
    cursor:pointer;
    position:relative;
    transition: all 0.12s ease;
    user-select: none;
  }
  .cell:hover { transform: translateY(-2px); background:#5a6578; }
  .cell.terrain { background: #1a1a1a; cursor:not-allowed; }
  .cell.deployment-a { box-shadow: inset 0 0 0 3px rgba(49,130,206,0.12); }
  .cell.deployment-b { box-shadow: inset 0 0 0 3px rgba(229,62,62,0.12); }
  .cell.highlighted { background: #38a169 !important; box-shadow: 0 0 10px #38a169; }
  .cell.attack-range { background: #e53e3e !important; box-shadow: 0 0 8px #e53e3e; }
  .cell.selected { background: #3182ce !important; box-shadow: 0 0 12px #3182ce; }

  .figure {
    width: 84%;
    height: 84%;
    border-radius: 50%;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:700;
    font-size:22px;
    line-height:1;
    position:relative;
    border: 2px solid rgba(0,0,0,0.2);
  }
  .figure.player-a { background:#3182ce; border-color:#2c5282; color:white; }
  .figure.player-b { background:#e53e3e; border-color:#c53030; color:white; }

  .figure .health {
    position:absolute;
    top:-8px;
    right:-8px;
    background:#1a202c;
    color:#e2e8f0;
    border-radius:50%;
    width:20px;
    height:20px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:11px;
    font-weight:800;
    border:1px solid #4a5568;
  }

  .actions { background: rgba(0,0,0,0.18); border-radius:10px; padding:12px; margin-top:10px; }
  .action-buttons { display:flex; gap:8px; flex-wrap:wrap; }
  .btn { padding:10px 14px; border-radius:8px; border:none; cursor:pointer; background:#3182ce; color:#fff; font-weight:600; min-width:120px; }
  .btn:disabled { background:#4a5568; opacity:0.7; cursor:not-allowed; }
  .btn.danger { background:#e53e3e; }
  .btn.success { background:#38a169; }

  .game-setup { text-align:center; padding:20px; margin-bottom:10px; }
  .character-select { display:grid; grid-template-columns: repeat(auto-fit, minmax(160px,1fr)); gap:12px; margin-top:12px; }
  .character-card { background: rgba(0,0,0,0.25); padding:12px; border-radius:10px; cursor:pointer; border:2px solid transparent; transition:transform .12s, background .12s; }
  .character-card:hover { transform: translateY(-4px); background: rgba(0,0,0,0.35); }
  .character-card.placing { border-color: #63b3ed; background: rgba(49,130,206,0.08); }

  /* Modal */
  .modal { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background: rgba(0,0,0,0.7); z-index:999; padding:18px; }
  .modal-content { background:#2d3748; border-radius:10px; padding:16px; width:420px; max-width:96%; color:#e2e8f0; }

  .spell-grid { display:grid; gap:8px; margin-top:10px; }
  .spell-card { background: rgba(0,0,0,0.2); padding:8px; border-radius:8px; cursor:pointer; border:2px solid transparent; }
  .spell-card:hover { border-color:#63b3ed; background: rgba(0,0,0,0.35); }

  /* Debug panel */
  #debugPanel {
    background: rgba(0,0,0,0.6);
    color: #e2e8f0;
    padding: 10px;
    font-size: 12px;
    max-height: 220px;
    overflow-y: auto;
    border-radius: 8px;
    margin-top: 12px;
  }

  @media (max-width: 900px) {
    .board { transform: scale(0.84); transform-origin:center top; }
  }
  @media (max-width: 600px) {
    .board { transform: scale(0.64); transform-origin:center top; }
    .cell { font-size: 20px; }
    .figure { font-size: 16px; }
  }
</style>
</head>
<body>
<div class="container">
  <div class="header"><h1>‚öîÔ∏è Motley Crews</h1></div>

  <!-- Setup area -->
  <div id="gameSetup" class="game-setup">
    <h2>Place Your Characters</h2>
    <p id="setupInstructions">Player A: select a character, then click a blue deployment square</p>
    <div id="characterSelect" class="character-select"></div>
    <div style="margin-top:10px;"><button id="startGameBtn" class="btn" style="display:none">Start Game</button></div>
  </div>

  <!-- Game board and controls -->
  <div id="gameBoard" style="display:none;">
    <div class="game-info">
      <div><div id="turnIndicator" class="turn-indicator turn-player-a">Player A's Turn</div></div>
      <div>Score: <span id="scoreA">0</span> - <span id="scoreB">0</span></div>
      <div>Turn: <span id="turnCounter">1</span></div>
    </div>

    <div id="statusEffects" class="status-effects" style="display:none;">
      <h4>Active Effects:</h4>
      <div id="effectsList"></div>
    </div>

    <div class="board-container">
      <div id="board" class="board"></div>
    </div>

    <div class="actions">
      <h3>Actions</h3>
      <div class="action-buttons">
        <button id="moveBtn" class="btn" disabled>Move</button>
        <button id="attackBtn" class="btn danger" disabled>Attack</button>
        <button id="specialBtn" class="btn" disabled>Special Action</button>
        <button id="endTurnBtn" class="btn success">End Turn</button>
      </div>

      <!-- debug panel -->
      <div id="debugPanel" aria-live="polite"></div>
    </div>
  </div>
</div>

<!-- Special ability modal (used for mages under Special Action) -->
<div id="spellModal" class="modal" style="display:none;">
  <div class="modal-content">
    <h3>Choose Special Ability</h3>
    <div id="spellGrid" class="spell-grid"></div>
    <div style="margin-top:10px; text-align:right;"><button class="btn" onclick="closeSpellModal()">Cancel</button></div>
  </div>
</div>

<script>
/* ===========================
   Game state & definitions
   =========================== */
let gameState = {
  currentPlayer: 'A',
  turnCount: 1,
  phase: 'setup', // 'setup' | 'playing' | 'ended'
  selectedFigure: null,   // cellId of selected figure during playing
  selectedAction: null,   // 'move' | 'attack' | 'charge' | 'longEye' | 'spell_NAME'
  hasMoved: false,        // prevents more than one move per turn
  hasActed: false,        // used for action restrictions
  score: { A: 0, B: 0 },
  board: {},              // cellId => { type, player, health, maxHealth, id }
  statusEffects: [],      // array of effects
  setupPhase: {
    currentPlayer: 'A',
    charactersToPlace: {
      A: ['Knight','Barbarian','Arbalist','Black Mage','White Mage'],
      B: ['Knight','Barbarian','Arbalist','Black Mage','White Mage']
    }
  },
  usedSpells: []          // for once-per-game spells
};

const characters = {
  'Knight':     { health:7, move:4, attack:3, reach:1, symbol:'‚ôû' },
  'Barbarian':  { health:6, move:3, attack:4, reach:1, symbol:'‚ö°' },
  'Arbalist':   { health:5, move:2, attack:2, reach:3, symbol:'üèπ' },
  'Black Mage': { health:4, move:2, attack:1, reach:2, symbol:'üîÆ' },
  'White Mage': { health:4, move:2, attack:1, reach:2, symbol:'‚ú®' }
};

const deploymentZones = {
  A: ['A1','A2','B1','B2','C1','C2','D1','D2','E1','E2','F1','F2','G1','G2','H1','H2'],
  B: ['A7','A8','B7','B8','C7','C8','D7','D8','E7','E8','F7','F8','G7','G8','H7','H8']
};

const terrainSquares = ['B4','G5'];

/* ===========================
   Utilities
   =========================== */
function parseCell(cellId) {
  const col = cellId.charCodeAt(0) - 64; // A=1
  const row = parseInt(cellId.slice(1),10);
  return [col,row];
}
function coordsToCell(col,row) {
  return `${String.fromCharCode(64+col)}${row}`;
}
function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }
function hasLivingFigures(player) {
  return Object.values(gameState.board).some(f => f.player === player);
}

/* ===========================
   Debugging: on-screen + console
   =========================== */
function logDebug(message, data) {
  const panel = document.getElementById('debugPanel');
  if (panel) {
    const row = document.createElement('div');
    row.textContent = `[DEBUG] ${message}` + (data ? ` ${JSON.stringify(data)}` : '');
    panel.appendChild(row);
    panel.scrollTop = panel.scrollHeight;
  }
  console.log('[DEBUG]', message, data || '');
}

/* ===========================
   Initialization & board creation
   =========================== */
function initGame() {
  createBoard();
  setupCharacterSelection();
  updateUI();
  // show board during setup so players can place characters
  document.getElementById('gameBoard').style.display = 'block';
}
function createBoard() {
  const board = document.getElementById('board');
  board.innerHTML = '';
  for (let row = 8; row >= 1; row--) {
    for (let col = 1; col <= 8; col++) {
      const cellId = `${String.fromCharCode(64+col)}${row}`;
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.id = cellId;
      cell.onclick = () => handleCellClick(cellId);

      if (terrainSquares.includes(cellId)) {
        cell.classList.add('terrain');
        cell.textContent = 'üèîÔ∏è';
      }

      if (deploymentZones.A.includes(cellId)) cell.classList.add('deployment-a');
      else if (deploymentZones.B.includes(cellId)) cell.classList.add('deployment-b');

      board.appendChild(cell);
    }
  }
}

/* ===========================
   Setup: character selection & placement
   =========================== */
function setupCharacterSelection() {
  const container = document.getElementById('characterSelect');
  container.innerHTML = '';
  const list = gameState.setupPhase.charactersToPlace[gameState.setupPhase.currentPlayer];

  list.forEach(name => {
    const card = document.createElement('div');
    card.className = 'character-card';
    card.onclick = (e) => selectCharacterForPlacement(name, e);
    const ch = characters[name];
    card.innerHTML = `
      <div style="font-size:28px; margin-bottom:8px;">${ch.symbol}</div>
      <h4 style="margin-bottom:6px;">${name}</h4>
      <div style="font-size:13px;">HP: ${ch.health} ‚Ä¢ Move: ${ch.move} ‚Ä¢ Atk: ${ch.attack} ‚Ä¢ Reach: ${ch.reach}</div>
    `;
    container.appendChild(card);
  });

  // hide start button until both finish
  document.getElementById('startGameBtn').style.display = 'none';
}

let selectedCharacterForPlacement = null;
function selectCharacterForPlacement(name, e) {
  document.querySelectorAll('.character-card').forEach(c => c.classList.remove('placing'));
  selectedCharacterForPlacement = name;
  const card = (e && e.currentTarget) || e.target.closest('.character-card');
  if (card) card.classList.add('placing');
  document.getElementById('setupInstructions').textContent =
    `Place ${name} in your deployment zone (${gameState.setupPhase.currentPlayer === 'A' ? 'blue' : 'red'} squares)`;
}

/* ===========================
   Cell click handling
   =========================== */
function handleCellClick(cellId) {
  if (gameState.phase === 'setup') {
    handleSetupClick(cellId);
  } else if (gameState.phase === 'playing') {
    handleGameClick(cellId);
  }
}

/* Setup placement */
function handleSetupClick(cellId) {
  if (!selectedCharacterForPlacement) {
    alert('Please select a character first');
    return;
  }
  const zone = deploymentZones[gameState.setupPhase.currentPlayer];
  if (!zone.includes(cellId)) {
    alert('You can only place characters in your deployment zone');
    return;
  }
  if (gameState.board[cellId]) {
    alert('Cell is already occupied');
    return;
  }

  const data = characters[selectedCharacterForPlacement];
  gameState.board[cellId] = {
    type: selectedCharacterForPlacement,
    player: gameState.setupPhase.currentPlayer,
    health: data.health,
    maxHealth: data.health,
    id: `${gameState.setupPhase.currentPlayer}_${selectedCharacterForPlacement}_${Date.now()}`
  };

  // remove from list
  const arr = gameState.setupPhase.charactersToPlace[gameState.setupPhase.currentPlayer];
  const idx = arr.indexOf(selectedCharacterForPlacement);
  if (idx >= 0) arr.splice(idx,1);

  // clear selection UI
  selectedCharacterForPlacement = null;
  document.querySelectorAll('.character-card').forEach(c => c.classList.remove('placing'));

  // switch or finish
  if (gameState.setupPhase.charactersToPlace[gameState.setupPhase.currentPlayer].length === 0) {
    if (gameState.setupPhase.currentPlayer === 'A' && gameState.setupPhase.charactersToPlace.B.length > 0) {
      gameState.setupPhase.currentPlayer = 'B';
      document.getElementById('setupInstructions').textContent = 'Player B: Place your characters (red squares)';
      setupCharacterSelection();
    } else {
      startGame();
      return;
    }
  } else {
    const remaining = gameState.setupPhase.charactersToPlace[gameState.setupPhase.currentPlayer].length;
    document.getElementById('setupInstructions').textContent =
      `Player ${gameState.setupPhase.currentPlayer}: Select a character (${remaining} remaining)`;
    setupCharacterSelection();
  }

  updateBoard();
}

/* Start game after placement */
function startGame() {
  gameState.phase = 'playing';
  document.getElementById('gameSetup').style.display = 'none';
  document.getElementById('gameBoard').style.display = 'block';
  updateUI();
  logDebug('Setup complete - game started', { currentPlayer: gameState.currentPlayer });
}

/* ===========================
   Selection / highlights / UI
   =========================== */
function selectFigure(cellId) {
  clearHighlights();
  gameState.selectedFigure = cellId;
  document.getElementById(cellId).classList.add('selected');
  updateActionButtons();
}

function clearSelection() {
  gameState.selectedFigure = null;
  gameState.selectedAction = null;
  clearHighlights();
  updateActionButtons();
}

function clearHighlights() {
  document.querySelectorAll('.cell').forEach(c => {
    c.classList.remove('highlighted','attack-range','selected');
  });
}

function updateActionButtons() {
  const figure = gameState.selectedFigure ? gameState.board[gameState.selectedFigure] : null;
  document.getElementById('moveBtn').disabled = !figure || gameState.hasMoved || figure.player !== gameState.currentPlayer;
  document.getElementById('attackBtn').disabled = !figure || figure.player !== gameState.currentPlayer;
  // Special covers Knight, Arbalist (can have special), and mages (spells)
  document.getElementById('specialBtn').disabled = !figure || !hasSpecialAction(figure.type) || figure.player !== gameState.currentPlayer;
}

function hasSpecialAction(type) {
  // Knight (charge), Arbalist (long eye passive, but still give special), Black/White Mages (spells)
  return ['Knight','Arbalist','Black Mage','White Mage'].includes(type);
}

/* ===========================
   Movement
   =========================== */
function startMove() {
  if (!gameState.selectedFigure || gameState.hasActed) return;
  gameState.selectedAction = 'move';
  highlightMovementRange();
}

function getValidMoves(fromCell, range) {
  const valid = [];
  const [fCol, fRow] = parseCell(fromCell);
  for (let row=1; row<=8; row++){
    for (let col=1; col<=8; col++){
      const cell = coordsToCell(col,row);
      const dist = Math.abs(row - fRow) + Math.abs(col - fCol);
      if (dist > 0 && dist <= range && isValidMoveTarget(cell)) valid.push(cell);
    }
  }
  return valid;
}

function isValidMoveTarget(cellId) {
  return !gameState.board[cellId] && !terrainSquares.includes(cellId);
}

function highlightMovementRange() {
  const figure = gameState.board[gameState.selectedFigure];
  if (!figure) return;
  const moveRange = characters[figure.type].move;
  const valid = getValidMoves(gameState.selectedFigure, moveRange);
  valid.forEach(c => document.getElementById(c).classList.add('highlighted'));
}

function handleMove(cellId) {
  if (!isValidMoveTarget(cellId)) return;
  const figure = gameState.board[gameState.selectedFigure];
  const moveRange = characters[figure.type].move;
  const [fCol,fRow] = parseCell(gameState.selectedFigure);
  const [tCol,tRow] = parseCell(cellId);
  const distance = Math.abs(tRow - fRow) + Math.abs(tCol - fCol);
  if (distance <= moveRange) {
    gameState.board[cellId] = figure;
    delete gameState.board[gameState.selectedFigure];
    gameState.selectedFigure = cellId;
    gameState.hasMoved = true; // one move per turn enforced
    logDebug('Move executed', { figure: figure.type, to: cellId, player: figure.player });
    clearHighlights();
    document.getElementById(cellId).classList.add('selected');
    updateBoard();
    updateActionButtons();
  }
}

/* ===========================
   Attacks (including Arbalist passive)
   =========================== */

function startAttack() {
  if (!gameState.selectedFigure) return;
  gameState.selectedAction = 'attack';
  highlightAttackRange();
}

function highlightAttackRange() {
  const from = gameState.selectedFigure;
  if (!from) return;
  const figure = gameState.board[from];
  const reach = characters[figure.type].reach;

  // Arbalist: use line-of-sight in 8 directions up to reach
  if (figure.type === 'Arbalist') {
    const directions = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
    const [fCol,fRow] = parseCell(from);
    directions.forEach(dir => {
      for (let i=1;i<=reach;i++){
        const col = fCol + dir[0]*i;
        const row = fRow + dir[1]*i;
        if (col < 1 || col > 8 || row < 1 || row > 8) break;
        const cell = coordsToCell(col,row);
        const target = gameState.board[cell];
        if (target && target.player !== figure.player) {
          document.getElementById(cell).classList.add('attack-range');
          break; // stop after hitting a figure
        }
        if (terrainSquares.includes(cell)) break;
      }
    });
    return;
  }

  // Default: Manhattan range
  const [fCol,fRow] = parseCell(from);
  for (let row=1; row<=8; row++){
    for (let col=1; col<=8; col++){
      const cell = coordsToCell(col,row);
      const target = gameState.board[cell];
      const dist = Math.abs(row - fRow) + Math.abs(col - fCol);
      if (target && target.player !== figure.player && dist <= reach) {
        document.getElementById(cell).classList.add('attack-range');
      }
    }
  }
}

function getValidAttackTargets(fromCell, reach) {
  const figure = gameState.board[fromCell];
  const targets = [];

  if (figure.type === 'Arbalist') {
    const directions = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
    const [fCol,fRow] = parseCell(fromCell);
    directions.forEach(dir => {
      for (let i=1;i<=reach;i++){
        const col = fCol + dir[0]*i;
        const row = fRow + dir[1]*i;
        if (col < 1 || col > 8 || row < 1 || row > 8) break;
        const cell = coordsToCell(col,row);
        if (terrainSquares.includes(cell)) break;
        const t = gameState.board[cell];
        if (t && t.player !== figure.player) {
          targets.push(cell);
          break;
        }
      }
    });
    return targets;
  }

  // Default: manhattan search within reach
  const [fCol,fRow] = parseCell(fromCell);
  for (let row=1;row<=8;row++){
    for (let col=1;col<=8;col++){
      const cell = coordsToCell(col,row);
      const t = gameState.board[cell];
      const dist = Math.abs(row - fRow) + Math.abs(col - fCol);
      if (t && t.player !== figure.player && dist <= reach) targets.push(cell);
    }
  }
  return targets;
}

function handleAttack(cellId) {
  const target = gameState.board[cellId];
  if (!target || target.player === gameState.currentPlayer) return;
  const attacker = gameState.board[gameState.selectedFigure];
  const reach = characters[attacker.type].reach;
  const [fCol,fRow] = parseCell(gameState.selectedFigure);
  const [tCol,tRow] = parseCell(cellId);
  const distance = Math.abs(tRow - fRow) + Math.abs(tCol - fCol);

  // For Arbalist, distance rule uses LOS handled in getValidAttackTargets; allow attack if target present and was highlighted
  if (attacker.type === 'Arbalist') {
    // verify in valid targets via LOS
    const valid = getValidAttackTargets(gameState.selectedFigure, attacker.reach);
    if (!valid.includes(cellId)) return;
  } else {
    if (distance > reach) return;
  }

  let damage = characters[attacker.type].attack;

  // Fear of the Occult: Barbarian takes +1 damage from Black Mage attacks
  if (target.type === 'Barbarian' && attacker.type === 'Black Mage') damage += 1;

  // NOTE: Barbarian has no berserker passive (per your instruction)

  target.health -= damage;
  logDebug('Attack executed', { attacker: attacker.type, target: target.type, damage, remainingHealth: target.health });

  if (target.health <= 0) {
    logDebug('Character defeated', { defeated: target.type, by: attacker.type, cell: cellId });
    delete gameState.board[cellId];
    gameState.score[gameState.currentPlayer]++;
  }

  gameState.hasActed = true;
  clearSelection();
  updateBoard();
  updateUI();
  checkWinConditions();
}

/* ===========================
   Special actions (Knight charge, Arbalist special already passive,
   Mages' spells accessible here via modal)
   =========================== */

function startSpecialAction() {
  const figCell = gameState.selectedFigure;
  if (!figCell) return;
  const figure = gameState.board[figCell];

  switch (figure.type) {
    case 'Knight':
      if (!gameState.hasMoved) {
        gameState.selectedAction = 'charge';
        highlightChargeRange();
      } else {
        alert("You can't use Charge after moving this turn");
      }
      break;
    case 'Arbalist':
      // Arbalist passive long-eye is always active in attacks; allow special to show info
      alert('Arbalist: Long Eye is always active. Use Attack to target distant enemies along straight lines.');
      break;
    case 'Black Mage':
    case 'White Mage':
      openSpellModal();
      break;
  }
}

/* Knight charge highlight */
function highlightChargeRange() {
  const from = gameState.selectedFigure;
  if (!from) return;
  const [fCol,fRow] = parseCell(from);
  const directions = [[0,1],[0,-1],[1,0],[-1,0]];
  directions.forEach(dir => {
    for (let i=1;i<=4;i++){
      const col = fCol + dir[0]*i;
      const row = fRow + dir[1]*i;
      if (col < 1 || col > 8 || row < 1 || row > 8) break;
      const cell = coordsToCell(col,row);
      if (terrainSquares.includes(cell) || gameState.board[cell]) break;
      document.getElementById(cell).classList.add('highlighted');
    }
  });
}

function handleCharge(cellId) {
  const from = gameState.selectedFigure;
  if (!from) return;
  const [fCol,fRow] = parseCell(from);
  const [tCol,tRow] = parseCell(cellId);
  const deltaRow = tRow - fRow;
  const deltaCol = tCol - fCol;
  if (deltaRow !== 0 && deltaCol !== 0) return; // must be straight
  const dist = Math.abs(deltaRow) + Math.abs(deltaCol);
  if (dist > 4) return;
  if (terrainSquares.includes(cellId)) return;
  if (gameState.board[cellId]) return;

  const figure = gameState.board[from];

  const stepRow = deltaRow === 0 ? 0 : deltaRow/Math.abs(deltaRow);
  const stepCol = deltaCol === 0 ? 0 : deltaCol/Math.abs(deltaCol);

  let curRow = fRow + stepRow, curCol = fCol + stepCol;
  while (curRow !== tRow || curCol !== tCol) {
    const pathCell = coordsToCell(curCol, curRow);
    const pfig = gameState.board[pathCell];
    if (pfig) {
      pfig.health -= 2;
      logDebug('Charge path damage', { target: pfig.type, cell: pathCell, damage:2, remaining: pfig.health });
      if (pfig.health <= 0) {
        logDebug('Character defeated', { defeated: pfig.type, by: figure.type });
        delete gameState.board[pathCell];
        gameState.score[figure.player]++;
      }
    }
    curRow += stepRow; curCol += stepCol;
  }

  // move knight
  gameState.board[cellId] = figure;
  delete gameState.board[from];
  gameState.selectedFigure = cellId;
  gameState.hasActed = true;
  clearSelection();
  updateBoard();
  updateUI();
  checkWinConditions();
}

/* ===========================
   Spell modal & mage spell handlers
   Spells are triggered through Special Action for mages.
   =========================== */

function openSpellModal() {
  const figCell = gameState.selectedFigure;
  if (!figCell) return;
  const figure = gameState.board[figCell];
  if (!figure || !['Black Mage','White Mage'].includes(figure.type)) return;

  const grid = document.getElementById('spellGrid');
  grid.innerHTML = '';
  const spells = getSpellsForCharacter(figure.type);
  spells.forEach(spell => {
    const card = document.createElement('div');
    card.className = 'spell-card';
    card.onclick = () => {
      selectSpell(spell.name);
    };
    card.innerHTML = `<strong>${spell.name}</strong><div style="font-size:13px;margin-top:6px;">${spell.description}</div>`;
    grid.appendChild(card);
  });

  document.getElementById('spellModal').style.display = 'flex';
}

function closeSpellModal() {
  document.getElementById('spellModal').style.display = 'none';
}

function getSpellsForCharacter(type) {
  const spells = {
    'Black Mage': [
      { name: 'Magic Bomb', description: 'Place bomb within 2 tiles. All figures in that cell and adjacent lose 2 life. Once per game.' },
      { name: 'Curse', description: 'Lose X life: one enemy within 2 loses X+1 life.' },
      { name: 'Animate Dead', description: 'Lose 1 life: resurrect one dead figure in your start zone with 2 life.' }
    ],
    'White Mage': [
      { name: 'Convert', description: 'Take control of an enemy with 2 or less life within 2.' },
      { name: 'Heal', description: 'Restore up to 3 life to a friendly figure within 2.' },
      { name: 'Conjure Containment', description: 'Enemy within 2 cannot move/attack/special for 2 turns.' }
    ]
  };
  return spells[type] || [];
}

function selectSpell(spellName) {
  gameState.selectedAction = `spell_${spellName}`;
  closeSpellModal();
  switch (spellName) {
    case 'Magic Bomb': highlightSpellRange(2); break;
    case 'Curse': highlightEnemiesInRange(2); break;
    case 'Animate Dead': handleAnimateDead(); break;
    case 'Convert': highlightConvertTargets(); break;
    case 'Heal': highlightHealTargets(); break;
    case 'Conjure Containment': highlightEnemiesInRange(2); break;
  }
}

/* Spell highlight helpers */
function highlightSpellRange(reach) {
  const from = gameState.selectedFigure;
  if (!from) return;
  const [fCol,fRow] = parseCell(from);
  for (let r=1;r<=8;r++){
    for (let c=1;c<=8;c++){
      const dist = Math.abs(r-fRow)+Math.abs(c-fCol);
      if (dist <= reach && !(r===fRow && c===fCol)) {
        document.getElementById(coordsToCell(c,r)).classList.add('highlighted');
      }
    }
  }
}
function highlightEnemiesInRange(reach) {
  const from = gameState.selectedFigure;
  if (!from) return;
  const [fCol,fRow] = parseCell(from);
  for (let r=1;r<=8;r++){
    for (let c=1;c<=8;c++){
      const cell = coordsToCell(c,r);
      const target = gameState.board[cell];
      const dist = Math.abs(r-fRow)+Math.abs(c-fCol);
      if (target && target.player !== gameState.currentPlayer && dist <= reach) {
        document.getElementById(cell).classList.add('attack-range');
      }
    }
  }
}
function highlightConvertTargets() { highlightEnemiesInRange(2); }
function highlightHealTargets() {
  const from = gameState.selectedFigure;
  if (!from) return;
  const [fCol,fRow] = parseCell(from);
  for (let r=1;r<=8;r++){
    for (let c=1;c<=8;c++){
      const cell = coordsToCell(c,r);
      const t = gameState.board[cell];
      const dist = Math.abs(r-fRow)+Math.abs(c-fCol);
      if (t && t.player === gameState.currentPlayer && dist <= 2) {
        document.getElementById(cell).classList.add('highlighted');
      }
    }
  }
}

/* Spell executors */
function handleSpellTarget(cellId) {
  const spellName = gameState.selectedAction?.replace('spell_','');
  if (!spellName) return;
  switch (spellName) {
    case 'Magic Bomb': handleMagicBomb(cellId); break;
    case 'Curse': handleCurse(cellId); break;
    case 'Convert': handleConvert(cellId); break;
    case 'Heal': handleHeal(cellId); break;
    case 'Conjure Containment': handleContainment(cellId); break;
  }
}

function handleMagicBomb(cellId) {
  if (!gameState.usedSpells) gameState.usedSpells = [];
  if (gameState.usedSpells.includes('Magic Bomb')) { alert('Magic Bomb already used'); return; }
  const caster = gameState.board[gameState.selectedFigure];
  const [fCol,fRow] = parseCell(gameState.selectedFigure);
  const [tCol,tRow] = parseCell(cellId);
  const dist = Math.abs(tRow-fRow)+Math.abs(tCol-fCol);
  if (dist > 2) return;
  gameState.usedSpells.push('Magic Bomb');
  logDebug('Magic Bomb cast', { caster: caster.type, targetCell: cellId });

  for (let r = tRow-1; r <= tRow+1; r++){
    for (let c = tCol-1; c <= tCol+1; c++){
      if (r>=1 && r<=8 && c>=1 && c<=8) {
        const cell = coordsToCell(c,r);
        const t = gameState.board[cell];
        if (t) {
          t.health -= 2;
          logDebug('Magic Bomb damage', { target: t.type, cell, remaining: t.health });
          if (t.health <= 0) {
            logDebug('Character defeated', { defeated: t.type, by: caster.type });
            delete gameState.board[cell];
            if (t.player !== gameState.currentPlayer) gameState.score[gameState.currentPlayer]++;
          }
        }
      }
    }
  }
  gameState.hasActed = true;
  clearSelection();
  updateBoard();
  updateUI();
  checkWinConditions();
}

function handleCurse(cellId) {
  const target = gameState.board[cellId];
  const caster = gameState.board[gameState.selectedFigure];
  if (!target || target.player === gameState.currentPlayer) return;
  const [fCol,fRow] = parseCell(gameState.selectedFigure);
  const [tCol,tRow] = parseCell(cellId);
  const dist = Math.abs(tRow-fRow)+Math.abs(tCol-fCol);
  if (dist > 2) return;
  const damage = parseInt(prompt('How much life do you want to lose? (X)', '1') || '0', 10);
  if (!damage || damage <= 0 || damage > caster.health) return;
  caster.health -= damage;
  target.health -= (damage + 1);
  logDebug('Curse cast', { caster: caster.type, target: target.type, casterLoss: damage, targetLoss: damage+1 });
  if (caster.health <= 0) {
    logDebug('Character defeated', { defeated: caster.type, by: 'Self (Curse)' });
    delete gameState.board[gameState.selectedFigure];
  }
  if (target.health <= 0) {
    logDebug('Character defeated', { defeated: target.type, by: caster.type });
    delete gameState.board[cellId];
    gameState.score[gameState.currentPlayer]++;
  }
  gameState.hasActed = true;
  clearSelection();
  updateBoard();
  updateUI();
  checkWinConditions();
}

function handleAnimateDead() {
  const caster = gameState.board[gameState.selectedFigure];
  if (!caster) return;
  caster.health -= 1;
  logDebug('Animate Dead used', { caster: caster.type });
  if (caster.health <= 0) {
    logDebug('Character defeated', { defeated: caster.type, by: 'Self (Animate Dead)' });
    delete gameState.board[gameState.selectedFigure];
  }
  // simple resurrect UI: resurrect first dead type missing in start zone
  const deadTypes = Object.keys(characters).filter(type => !Object.values(gameState.board).some(f => f.type === type && f.player === gameState.currentPlayer));
  if (deadTypes.length) {
    const choice = prompt(`Choose character to resurrect: ${deadTypes.join(', ')}`, deadTypes[0]);
    if (choice && deadTypes.includes(choice)) {
      const startZone = deploymentZones[gameState.currentPlayer];
      const empty = startZone.find(c => !gameState.board[c]);
      if (empty) {
        gameState.board[empty] = {
          type: choice,
          player: gameState.currentPlayer,
          health: 2,
          maxHealth: characters[choice].health,
          id: `${gameState.currentPlayer}_${choice}_revived_${Date.now()}`
        };
        logDebug('Revive executed', { revived: choice, player: gameState.currentPlayer, cell: empty });
      } else {
        alert('No empty start zone to resurrect into.');
      }
    }
  } else {
    alert('No valid dead characters to resurrect.');
  }
  gameState.hasActed = true;
  clearSelection();
  updateBoard();
  updateUI();
}

function handleConvert(cellId) {
  const target = gameState.board[cellId];
  const caster = gameState.board[gameState.selectedFigure];
  if (!target || target.player === gameState.currentPlayer || target.health > 2) return;
  const [fCol,fRow] = parseCell(gameState.selectedFigure);
  const [tCol,tRow] = parseCell(cellId);
  const dist = Math.abs(tRow-fRow)+Math.abs(tCol-fCol);
  if (dist > 2) return;
  target.player = gameState.currentPlayer;
  target.id = `${gameState.currentPlayer}_${target.type}_converted_${Date.now()}`;
  logDebug('Convert success', { target: target.type, newPlayer: target.player });
  gameState.hasActed = true;
  clearSelection();
  updateBoard();
  updateUI();
}

function handleHeal(cellId) {
  const target = gameState.board[cellId];
  const caster = gameState.board[gameState.selectedFigure];
  if (!target || target.player !== gameState.currentPlayer) return;
  const [fCol,fRow] = parseCell(gameState.selectedFigure);
  const [tCol,tRow] = parseCell(cellId);
  const dist = Math.abs(tRow-fRow)+Math.abs(tCol-fCol);
  if (dist > 2) return;
  const healAmount = Math.min(3, (target.maxHealth || characters[target.type].health) - target.health);
  target.health += healAmount;
  logDebug('Heal cast', { caster: caster.type, target: target.type, healed: healAmount, newHealth: target.health });
  gameState.hasActed = true;
  clearSelection();
  updateBoard();
  updateUI();
}

function handleContainment(cellId) {
  const target = gameState.board[cellId];
  const caster = gameState.board[gameState.selectedFigure];
  if (!target || target.player === gameState.currentPlayer) return;
  const [fCol,fRow] = parseCell(gameState.selectedFigure);
  const [tCol,tRow] = parseCell(cellId);
  const dist = Math.abs(tRow-fRow)+Math.abs(tCol-fCol);
  if (dist > 2) return;
  gameState.statusEffects.push({ type:'contained', targetId: target.id, cellId, turnsLeft:2 });
  logDebug('Containment applied', { target: target.type, cell: cellId, turns:2 });
  gameState.hasActed = true;
  clearSelection();
  updateBoard();
  updateUI();
}

/* ===========================
   Turn handling
   =========================== */
function endTurn() {
  // Decrement status effects
  gameState.statusEffects.forEach(e => e.turnsLeft--);
  gameState.statusEffects = gameState.statusEffects.filter(e => e.turnsLeft > 0 || (logDebug(`Status expired`, e), false)); // will drop zeros
  // rotate player
  const prev = gameState.currentPlayer;
  gameState.currentPlayer = (gameState.currentPlayer === 'A') ? 'B' : 'A';
  gameState.turnCount++;
  gameState.hasMoved = false;
  gameState.hasActed = false;
  clearSelection();
  updateUI();
  logDebug('Turn ended', { from: prev, to: gameState.currentPlayer, turn: gameState.turnCount });
}

/* ===========================
   Win checks
   =========================== */
function checkWinConditions() {
  if (gameState.score.A >= 4) endGame('A');
  else if (gameState.score.B >= 4) endGame('B');
  else if (!hasLivingFigures('A')) endGame('B');
  else if (!hasLivingFigures('B')) endGame('A');
}
function endGame(winner) {
  gameState.phase = 'ended';
  logDebug('Game ended', { winner });
  setTimeout(()=>alert(`Player ${winner} wins!`), 50);
}

/* ===========================
   UI: board / status update
   =========================== */
function updateBoard() {
  // clear figures
  document.querySelectorAll('.figure').forEach(n => n.remove());
  // add
  Object.entries(gameState.board).forEach(([cellId, fig]) => {
    const cell = document.getElementById(cellId);
    if (!cell) return;
    const node = document.createElement('div');
    node.className = `figure player-${fig.player.toLowerCase()}`;
    node.innerHTML = `${characters[fig.type].symbol}<div class="health">${fig.health}</div>`;
    // clicking a figure should select it (during playing)
    node.onclick = (e) => {
      e.stopPropagation();
      if (gameState.phase === 'playing' && fig.player === gameState.currentPlayer) {
        selectFigure(cellId);
      } else {
        // If clicking enemy while in attack mode, handle
        if (gameState.phase === 'playing' && gameState.selectedAction && (gameState.selectedAction==='attack' || gameState.selectedAction?.startsWith('spell_') || gameState.selectedAction==='charge' || gameState.selectedAction==='longEye')) {
          handleGameClick(cellId);
        }
      }
    };
    cell.appendChild(node);
  });
}

function updateStatusEffects() {
  const sdiv = document.getElementById('statusEffects');
  const list = document.getElementById('effectsList');
  if (gameState.statusEffects.length) {
    sdiv.style.display = 'block';
    list.innerHTML = gameState.statusEffects.map(e => {
      const fig = gameState.board[e.cellId];
      return `${fig?.type || 'Unknown'} ${e.type} (${e.turnsLeft} turns left)`;
    }).join('<br>');
  } else {
    sdiv.style.display = 'none';
    list.innerHTML = '';
  }
}

function updateUI() {
  // Turn indicator
  const ti = document.getElementById('turnIndicator');
  ti.textContent = `Player ${gameState.currentPlayer}'s Turn`;
  ti.className = `turn-indicator turn-player-${gameState.currentPlayer.toLowerCase()}`;

  // Scores & turn counter
  document.getElementById('scoreA').textContent = gameState.score.A;
  document.getElementById('scoreB').textContent = gameState.score.B;
  document.getElementById('turnCounter').textContent = gameState.turnCount;

  // status effects
  updateStatusEffects();

  // board
  updateBoard();
  // update action buttons state
  updateActionButtons();
}

/* ===========================
   General game click handling for playing phase
   =========================== */
function handleGameClick(cellId) {
  const figure = gameState.board[cellId];
  // If player is choosing a spell target
  if (gameState.selectedAction && gameState.selectedAction.startsWith('spell_')) {
    handleSpellTarget(cellId);
    return;
  }
  if (gameState.selectedAction === 'move' && gameState.selectedFigure) {
    handleMove(cellId);
    return;
  }
  if (gameState.selectedAction === 'attack' && gameState.selectedFigure) {
    handleAttack(cellId);
    return;
  }
  if (gameState.selectedAction === 'charge' && gameState.selectedFigure) {
    handleCharge(cellId);
    return;
  }
  // selection: pick your own figure
  if (figure && figure.player === gameState.currentPlayer) {
    selectFigure(cellId);
    return;
  }
  // Clicking an enemy while a figure is selected and an action chosen may trigger that action
  clearSelection();
}

/* ===========================
   Event bindings
   =========================== */
document.getElementById('moveBtn').onclick = startMove;
document.getElementById('attackBtn').onclick = startAttack;
document.getElementById('specialBtn').onclick = startSpecialAction;
document.getElementById('endTurnBtn').onclick = endTurn;

// Attach click for selecting placed character cards to be safe (setup)
document.getElementById('startGameBtn').onclick = startGame;

// Listen for clicks on board cells for spells / actions by class approach (already wired per cell onclick)

/* Keyboard shortcuts (optional): M=move, A=attack, S=special, E=end turn */
window.addEventListener('keydown', (e) => {
  if (gameState.phase !== 'playing') return;
  const k = e.key.toLowerCase();
  if (k === 'm') startMove();
  if (k === 'a') startAttack();
  if (k === 's') startSpecialAction();
  if (k === 'e') endTurn();
});

/* ===========================
   Initialization call
   =========================== */
initGame();

/* ===========================
   Notes:
   - Serve with a simple local HTTP server (python -m http.server)
   - Debug panel prints actions & events; also use browser console
   - If you want additional logging (status expiry, effect application), let me know
   =========================== */
</script>
</body>
</html>