<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motley Crews</title>
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiTW90bGV5IENyZXdzIiwic2hvcnRfbmFtZSI6Ik1vdGxleSIsInN0YXJ0X3VybCI6Ii8iLCJkaXNwbGF5Ijoic3RhbmRhbG9uZSIsInRoZW1lX2NvbG9yIjoiIzJkM2E0ZiIsImJhY2tncm91bmRfY29sb3IiOiIjMWEyMDJjIn0=">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%);
            color: #e2e8f0;
            min-height: 100vh;
            padding: 10px;
            overflow-x: hidden;
        }

        .container {
            max-width: 100vw;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            padding: 15px 0;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 14px;
        }

        .board-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            background: #2d3748;
            padding: 8px;
            border-radius: 10px;
            max-width: 90vw;
            aspect-ratio: 1;
        }

        .cell {
            aspect-ratio: 1;
            background: #4a5568;
            border: 1px solid #2d3748;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
        }

        .cell:hover { background: #5a6578; }
        .cell.terrain { background: #1a1a1a; cursor: not-allowed; }
        .cell.deployment-a { background: #1a365d; }
        .cell.deployment-b { background: #742a2a; }
        .cell.highlighted { background: #38a169 !important; box-shadow: 0 0 10px #38a169; }
        .cell.attack-range { background: #e53e3e !important; box-shadow: 0 0 8px #e53e3e; }
        .cell.selected { background: #3182ce !important; box-shadow: 0 0 12px #3182ce; }

        .figure {
            width: 90%;
            height: 90%;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 10px;
            text-align: center;
            line-height: 1;
            cursor: pointer;
            position: relative;
            border: 2px solid;
        }

        .figure.player-a { background: #3182ce; border-color: #2c5282; color: white; }
        .figure.player-b { background: #e53e3e; border-color: #c53030; color: white; }

        .figure .health {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #1a202c;
            color: #e2e8f0;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            font-weight: bold;
            border: 1px solid #4a5568;
        }

        .actions { background: rgba(0,0,0,0.2); border-radius: 10px; padding: 15px; margin-bottom: 20px; }
        .actions h3 { margin-bottom: 10px; color: #63b3ed; }
        .action-buttons { display: flex; flex-wrap: wrap; gap: 8px; }
        .btn { padding: 12px 16px; background: #3182ce; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; transition: all 0.2s ease; flex: 1; min-width: 120px; }
        .btn:hover:not(:disabled) { background: #2c5282; transform: translateY(-1px); }
        .btn:disabled { background: #4a5568; cursor: not-allowed; opacity: 0.6; }
        .btn.danger { background: #e53e3e; }
        .btn.danger:hover:not(:disabled) { background: #c53030; }
        .btn.success { background: #38a169; }
        .btn.success:hover:not(:disabled) { background: #2f855a; }

        .game-setup { text-align: center; padding: 40px 20px; }
        .character-select { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin: 20px 0; }
        .character-card { background: rgba(0,0,0,0.3); border-radius: 10px; padding: 15px; cursor: pointer; transition: all 0.2s ease; border: 2px solid transparent; }
        .character-card:hover { background: rgba(0,0,0,0.5); transform: translateY(-2px); }
        .character-card.placing { border-color: #3182ce; background: rgba(49, 130, 206, 0.2); }

        .modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 1000; padding: 20px; }
        .modal-content { background: #2d3748; border-radius: 10px; padding: 20px; max-width: 400px; width: 100%; max-height: 80vh; overflow-y: auto; }
        .spell-grid { display: grid; gap: 10px; margin-top: 15px; }
        .spell-card { background: rgba(0,0,0,0.3); border-radius: 8px; padding: 12px; cursor: pointer; transition: all 0.2s ease; border: 2px solid transparent; }
        .spell-card:hover { background: rgba(0,0,0,0.5); border-color: #3182ce; }
        .spell-card h4 { color: #63b3ed; margin-bottom: 5px; }
        .status-effects { background: rgba(0,0,0,0.2); border-radius: 8px; padding: 10px; margin-bottom: 15px; }

        .turn-indicator { padding: 8px 16px; border-radius: 20px; font-weight: bold; text-align: center; }
        .turn-player-a { background: #3182ce; color: white; }
        .turn-player-b { background: #e53e3e; color: white; }

        @media (max-width: 600px) {
            .board { max-width: 95vw; }
            .figure { font-size: 8px; }
            .figure .health { width: 14px; height: 14px; font-size: 7px; }
            .btn { min-width: 100px; padding: 10px 12px; font-size: 13px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚öîÔ∏è Motley Crews</h1>
        </div>

        <div id="gameSetup" class="game-setup">
            <h2>Place Your Characters</h2>
            <p id="setupInstructions">Click a character, then click a cell in your deployment zone</p>

            <div class="character-select" id="characterSelect">
                <!-- Characters will be populated here -->
            </div>

            <button class="btn" id="startGameBtn" style="display: none;">Start Game</button>
        </div>

        <div id="gameBoard" style="display: none;">
            <div class="game-info">
                <div>
                    <div class="turn-indicator" id="turnIndicator">Player A's Turn</div>
                </div>
                <div>Score: <span id="scoreA">0</span> - <span id="scoreB">0</span></div>
                <div>Turn: <span id="turnCounter">1</span></div>
            </div>

            <div id="statusEffects" class="status-effects" style="display: none;">
                <h4>Active Effects:</h4>
                <div id="effectsList"></div>
            </div>

            <div class="board-container">
                <div class="board" id="board">
                    <!-- Board cells will be generated here -->
                </div>
            </div>

            <div class="actions">
                <h3>Actions</h3>
                <div class="action-buttons">
                    <button class="btn" id="moveBtn" disabled>Move</button>
                    <button class="btn danger" id="attackBtn" disabled>Attack</button>
                    <button class="btn" id="specialBtn" disabled>Special Action</button>
                    <button class="btn" id="spellBtn" disabled>Cast Spell</button>
                    <button class="btn success" id="endTurnBtn">End Turn</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Spell Modal -->
    <div id="spellModal" class="modal" style="display: none;">
        <div class="modal-content">
            <h3>Choose Spell</h3>
            <div id="spellGrid" class="spell-grid">
                <!-- Spells will be populated here -->
            </div>
            <button class="btn" onclick="closeSpellModal()" style="margin-top: 15px;">Cancel</button>
        </div>
    </div>

    <script>
        // Game state
        let gameState = {
            currentPlayer: 'A',
            turnCount: 1,
            phase: 'setup', // setup, playing, ended
            selectedFigure: null,
            selectedAction: null,
            hasMoved: false,
            hasActed: false,
            score: { A: 0, B: 0 },
            board: {},
            statusEffects: [],
            setupPhase: {
                currentPlayer: 'A',
                charactersToPlace: {
                    A: ['Knight', 'Barbarian', 'Arbalist', 'Black Mage', 'White Mage'],
                    B: ['Knight', 'Barbarian', 'Arbalist', 'Black Mage', 'White Mage']
                }
            }
        };

        // Character definitions
        const characters = {
            'Knight': { health: 7, move: 4, attack: 3, reach: 1, symbol: '‚ôû' },
            'Barbarian': { health: 6, move: 3, attack: 4, reach: 1, symbol: '‚ö°' },
            'Arbalist': { health: 5, move: 2, attack: 2, reach: 3, symbol: 'üèπ' },
            'Black Mage': { health: 4, move: 2, attack: 1, reach: 2, symbol: 'üîÆ' },
            'White Mage': { health: 4, move: 2, attack: 1, reach: 2, symbol: '‚ú®' }
        };

        // Board configuration
        const deploymentZones = {
            A: ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2', 'E1', 'E2', 'F1', 'F2', 'G1', 'G2', 'H1', 'H2'],
            B: ['A7', 'A8', 'B7', 'B8', 'C7', 'C8', 'D7', 'D8', 'E7', 'E8', 'F7', 'F8', 'G7', 'G8', 'H7', 'H8']
        };

        const terrainSquares = ['B4', 'G5'];

        // Initialize the game
        function initGame() {
            createBoard();
            setupCharacterSelection();
            updateUI();
            // show board during setup so players can place
            document.getElementById('gameBoard').style.display = 'block';
        }

        function createBoard() {
            const board = document.getElementById('board');
            board.innerHTML = '';

            for (let row = 8; row >= 1; row--) {
                for (let col = 1; col <= 8; col++) {
                    const colLetter = String.fromCharCode(64 + col); // A-H
                    const cellId = `${colLetter}${row}`;
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = cellId;
                    cell.onclick = () => handleCellClick(cellId);

                    // Add terrain
                    if (terrainSquares.includes(cellId)) {
                        cell.classList.add('terrain');
                        cell.textContent = 'üèîÔ∏è';
                    }

                    // Add deployment zones
                    if (deploymentZones.A.includes(cellId)) {
                        cell.classList.add('deployment-a');
                    } else if (deploymentZones.B.includes(cellId)) {
                        cell.classList.add('deployment-b');
                    }

                    board.appendChild(cell);
                }
            }
        }

        function setupCharacterSelection() {
            const characterSelect = document.getElementById('characterSelect');
            characterSelect.innerHTML = '';

            gameState.setupPhase.charactersToPlace[gameState.setupPhase.currentPlayer].forEach(charName => {
                const card = document.createElement('div');
                card.className = 'character-card';
                card.onclick = (e) => selectCharacterForPlacement(charName, e);
                
                const char = characters[charName];
                card.innerHTML = `
                    <div style="font-size: 24px; margin-bottom: 10px;">${char.symbol}</div>
                    <h4>${charName}</h4>
                    <div>Health: ${char.health}</div>
                    <div>Move: ${char.move}</div>
                    <div>Attack: ${char.attack}</div>
                    <div>Reach: ${char.reach}</div>
                `;
                
                characterSelect.appendChild(card);
            });

            // Update start button visibility (not necessary but kept for UI)
            const startBtn = document.getElementById('startGameBtn');
            startBtn.style.display = 'none';
        }

        let selectedCharacterForPlacement = null;

        function selectCharacterForPlacement(charName, event) {
            // Remove previous selection
            document.querySelectorAll('.character-card').forEach(card => {
                card.classList.remove('placing');
            });

            // Select new character
            selectedCharacterForPlacement = charName;
            const card = event?.currentTarget || event?.target?.closest?.('.character-card');
            if (card) card.classList.add('placing');
            
            document.getElementById('setupInstructions').textContent = 
                `Place ${charName} in your deployment zone (${gameState.setupPhase.currentPlayer === 'A' ? 'blue' : 'red'} squares)`;
        }

        function handleCellClick(cellId) {
            if (gameState.phase === 'setup') {
                handleSetupClick(cellId);
            } else if (gameState.phase === 'playing') {
                handleGameClick(cellId);
            }
        }

        function handleSetupClick(cellId) {
            if (!selectedCharacterForPlacement) {
                alert('Please select a character first');
                return;
            }

            const currentPlayerZone = deploymentZones[gameState.setupPhase.currentPlayer];
            if (!currentPlayerZone.includes(cellId)) {
                alert('You can only place characters in your deployment zone');
                return;
            }

            if (gameState.board[cellId]) {
                alert('Cell is already occupied');
                return;
            }

            // Place the character
            const charData = characters[selectedCharacterForPlacement];
            gameState.board[cellId] = {
                type: selectedCharacterForPlacement,
                player: gameState.setupPhase.currentPlayer,
                health: charData.health,
                maxHealth: charData.health,
                id: `${gameState.setupPhase.currentPlayer}_${selectedCharacterForPlacement}`
            };

            // Remove from available characters
            const index = gameState.setupPhase.charactersToPlace[gameState.setupPhase.currentPlayer].indexOf(selectedCharacterForPlacement);
            gameState.setupPhase.charactersToPlace[gameState.setupPhase.currentPlayer].splice(index, 1);

            // Clear selection
            selectedCharacterForPlacement = null;
            document.querySelectorAll('.character-card').forEach(card => {
                card.classList.remove('placing');
            });

            // Check if current player is done
            if (gameState.setupPhase.charactersToPlace[gameState.setupPhase.currentPlayer].length === 0) {
                if (gameState.setupPhase.currentPlayer === 'A' && gameState.setupPhase.charactersToPlace.B.length > 0) {
                    // Switch to player B
                    gameState.setupPhase.currentPlayer = 'B';
                    document.getElementById('setupInstructions').textContent = 'Player B: Place your characters';
                    setupCharacterSelection();
                } else {
                    // Setup complete
                    startGame();
                    return;
                }
            } else {
                // Update instruction for remaining placements
                const remaining = gameState.setupPhase.charactersToPlace[gameState.setupPhase.currentPlayer].length;
                document.getElementById('setupInstructions').textContent = 
                    `Player ${gameState.setupPhase.currentPlayer}: Select a character to place (${remaining} remaining)`;
                setupCharacterSelection();
            }

            updateBoard();
        }

        function startGame() {
            gameState.phase = 'playing';
            document.getElementById('gameSetup').style.display = 'none';
            document.getElementById('gameBoard').style.display = 'block';
            updateUI();
        }

        function handleGameClick(cellId) {
            const figure = gameState.board[cellId];

            if (gameState.selectedAction === 'move' && gameState.selectedFigure) {
                handleMove(cellId);
            } else if (gameState.selectedAction === 'attack' && gameState.selectedFigure) {
                handleAttack(cellId);
            } else if (gameState.selectedAction && gameState.selectedAction.startsWith('spell_')) {
                handleSpellTarget(cellId);
            } else if (gameState.selectedAction === 'charge' && gameState.selectedFigure) {
                handleCharge(cellId);
            } else if (gameState.selectedAction === 'longEye' && gameState.selectedFigure) {
                handleLongEye(cellId);
            } else if (figure && figure.player === gameState.currentPlayer) {
                selectFigure(cellId);
            } else {
                clearSelection();
            }
        }

        function selectFigure(cellId) {
            clearHighlights();
            gameState.selectedFigure = cellId;
            document.getElementById(cellId).classList.add('selected');
            updateActionButtons();
        }

        function clearSelection() {
            gameState.selectedFigure = null;
            gameState.selectedAction = null;
            clearHighlights();
            updateActionButtons();
        }

        function clearHighlights() {
            document.querySelectorAll('.cell').forEach(cell => {
                cell.classList.remove('highlighted', 'attack-range', 'selected');
            });
        }

        function updateActionButtons() {
            const figure = gameState.selectedFigure ? gameState.board[gameState.selectedFigure] : null;
            
            document.getElementById('moveBtn').disabled = !figure || gameState.hasActed;
            document.getElementById('attackBtn').disabled = !figure;
            document.getElementById('specialBtn').disabled = !figure || !hasSpecialAction(figure.type);
            document.getElementById('spellBtn').disabled = !figure || !isSpellcaster(figure.type);
        }

        function hasSpecialAction(type) { return ['Knight', 'Arbalist'].includes(type); }
        function isSpellcaster(type) { return ['Black Mage', 'White Mage'].includes(type); }

        // Movement logic
        function startMove() {
            if (!gameState.selectedFigure || gameState.hasActed) return;
            
            gameState.selectedAction = 'move';
            highlightMovementRange();
        }

        function highlightMovementRange() {
            const figure = gameState.board[gameState.selectedFigure];
            const moveRange = characters[figure.type].move;
            const validMoves = getValidMoves(gameState.selectedFigure, moveRange);
            
            validMoves.forEach(cellId => {
                document.getElementById(cellId).classList.add('highlighted');
            });
        }

        function getValidMoves(fromCell, moveRange) {
            const validMoves = [];
            const [fromCol, fromRow] = parseCell(fromCell);
            
            for (let row = 1; row <= 8; row++) {
                for (let col = 1; col <= 8; col++) {
                    const cellId = `${String.fromCharCode(64 + col)}${row}`;
                    const distance = Math.abs(row - fromRow) + Math.abs(col - fromCol);
                    
                    if (distance <= moveRange && distance > 0 && isValidMoveTarget(cellId)) {
                        validMoves.push(cellId);
                    }
                }
            }
            
            return validMoves;
        }

        function isValidMoveTarget(cellId) { return !gameState.board[cellId] && !terrainSquares.includes(cellId); }

        function handleMove(cellId) {
            if (!isValidMoveTarget(cellId)) return;
            
            const figure = gameState.board[gameState.selectedFigure];
            const moveRange = characters[figure.type].move;
            const [fromCol, fromRow] = parseCell(gameState.selectedFigure);
            const [toCol, toRow] = parseCell(cellId);
            const distance = Math.abs(toRow - fromRow) + Math.abs(toCol - fromCol);
            
            if (distance <= moveRange) {
                // Move the figure
                gameState.board[cellId] = figure;
                delete gameState.board[gameState.selectedFigure];
                gameState.selectedFigure = cellId;
                gameState.hasMoved = true;
                
                clearHighlights();
                document.getElementById(cellId).classList.add('selected');
                updateBoard();
                updateActionButtons();
            }
        }

        // Attack logic
        function startAttack() {
            if (!gameState.selectedFigure) return;
            
            gameState.selectedAction = 'attack';
            highlightAttackRange();
        }

        function highlightAttackRange() {
            const figure = gameState.board[gameState.selectedFigure];
            const reach = characters[figure.type].reach;
            const validTargets = getValidAttackTargets(gameState.selectedFigure, reach);
            
            validTargets.forEach(cellId => {
                document.getElementById(cellId).classList.add('attack-range');
            });
        }

        function getValidAttackTargets(fromCell, reach) {
            const validTargets = [];
            const [fromCol, fromRow] = parseCell(fromCell);
            const figure = gameState.board[fromCell];
            
            for (let row = 1; row <= 8; row++) {
                for (let col = 1; col <= 8; col++) {
                    const cellId = `${String.fromCharCode(64 + col)}${row}`;
                    const target = gameState.board[cellId];
                    
                    if (target && target.player !== figure.player) {
                        const distance = Math.abs(row - fromRow) + Math.abs(col - fromCol);
                        if (distance <= reach) {
                            validTargets.push(cellId);
                        }
                    }
                }
            }
            
            return validTargets;
        }

        function handleAttack(cellId) {
            const target = gameState.board[cellId];
            if (!target || target.player === gameState.currentPlayer) return;
            
            const attacker = gameState.board[gameState.selectedFigure];
            const reach = characters[attacker.type].reach;
            const [fromCol, fromRow] = parseCell(gameState.selectedFigure);
            const [toCol, toRow] = parseCell(cellId);
            const distance = Math.abs(toRow - fromRow) + Math.abs(toCol - fromCol);
            
            if (distance <= reach) {
                let damage = characters[attacker.type].attack;
                
                // Apply special damage modifiers
                if (target.type === 'Barbarian' && attacker.type === 'Black Mage') {
                    damage += 1; // Fear of the Occult
                }
                
                target.health -= damage;
                
                if (target.health <= 0) {
                    // Figure dies
                    delete gameState.board[cellId];
                    gameState.score[gameState.currentPlayer]++;
                    
                    // Check win condition
                    if (gameState.score[gameState.currentPlayer] >= 4 || !hasLivingFigures(target.player)) {
                        endGame(gameState.currentPlayer);
                        return;
                    }
                }
                
                gameState.hasActed = true;
                clearSelection();
                updateBoard();
                updateUI();
            }
        }

        // Special actions
        function startSpecialAction() {
            const figure = gameState.board[gameState.selectedFigure];
            if (!figure) return;
            
            switch (figure.type) {
                case 'Knight':
                    if (!gameState.hasMoved) {
                        gameState.selectedAction = 'charge';
                        highlightChargeRange();
                    } else {
                        alert("You can't use Charge after moving this turn");
                    }
                    break;
                case 'Arbalist':
                    gameState.selectedAction = 'longEye';
                    highlightLongEyeRange();
                    break;
            }
        }

        function highlightChargeRange() {
            const [fromCol, fromRow] = parseCell(gameState.selectedFigure);
            
            // Highlight straight lines up to 4 spaces
            for (let direction of [[0,1], [0,-1], [1,0], [-1,0]]) {
                for (let i = 1; i <= 4; i++) {
                    const newRow = fromRow + (direction[1] * i);
                    const newCol = fromCol + (direction[0] * i);
                    
                    if (newRow >= 1 && newRow <= 8 && newCol >= 1 && newCol <= 8) {
                        const cellId = `${String.fromCharCode(64 + newCol)}${newRow}`;
                        if (!terrainSquares.includes(cellId)) {
                            document.getElementById(cellId).classList.add('highlighted');
                        }
                    }
                }
            }
        }

        function handleCharge(cellId) {
            const [fromCol, fromRow] = parseCell(gameState.selectedFigure);
            const [toCol, toRow] = parseCell(cellId);
            
            // Check if it's a straight line
            const deltaRow = toRow - fromRow;
            const deltaCol = toCol - fromCol;
            
            if (deltaRow !== 0 && deltaCol !== 0) return; // Not straight line
            if (Math.abs(deltaRow) + Math.abs(deltaCol) > 4) return; // Too far
            if (terrainSquares.includes(cellId)) return; // Can't move to terrain
            if (gameState.board[cellId]) return; // Can't move to occupied cell
            
            // Execute charge
            const figure = gameState.board[gameState.selectedFigure];
            
            // Damage figures along the path
            const stepRow = deltaRow === 0 ? 0 : deltaRow / Math.abs(deltaRow);
            const stepCol = deltaCol === 0 ? 0 : deltaCol / Math.abs(deltaCol);
            
            let currentRow = fromRow + stepRow;
            let currentCol = fromCol + stepCol;
            
            while (currentRow !== toRow || currentCol !== toCol) {
                const pathCellId = `${String.fromCharCode(64 + currentCol)}${currentRow}`;
                const pathFigure = gameState.board[pathCellId];
                
                if (pathFigure) {
                    pathFigure.health -= 2;
                    if (pathFigure.health <= 0) {
                        delete gameState.board[pathCellId];
                        gameState.score[gameState.currentPlayer]++;
                    }
                }
                
                currentRow += stepRow;
                currentCol += stepCol;
            }
            
            // Move the knight
            gameState.board[cellId] = figure;
            delete gameState.board[gameState.selectedFigure];
            gameState.selectedFigure = cellId;
            gameState.hasActed = true;
            
            clearSelection();
            updateBoard();
            updateUI();
            
            // Check win conditions
            checkWinConditions();
        }

        function highlightLongEyeRange() {
            const [fromCol, fromRow] = parseCell(gameState.selectedFigure);
            
            // Highlight all directions (including diagonal)
            for (let direction of [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]]) {
                for (let i = 1; i <= 8; i++) {
                    const newRow = fromRow + (direction[1] * i);
                    const newCol = fromCol + (direction[0] * i);
                    
                    if (newRow >= 1 && newRow <= 8 && newCol >= 1 && newCol <= 8) {
                        const cellId = `${String.fromCharCode(64 + newCol)}${newRow}`;
                        const target = gameState.board[cellId];
                        
                        if (target) {
                            if (target.player !== gameState.currentPlayer) {
                                document.getElementById(cellId).classList.add('attack-range');
                            }
                            break; // Can't attack through figures
                        }
                        
                        if (terrainSquares.includes(cellId)) {
                            break; // Can't attack through terrain
                        }
                    }
                }
            }
        }

        function handleLongEye(cellId) {
            const target = gameState.board[cellId];
            if (!target || target.player === gameState.currentPlayer) return;
            
            const [fromCol, fromRow] = parseCell(gameState.selectedFigure);
            const [toCol, toRow] = parseCell(cellId);
            
            // Check if it's in a straight line (including diagonal)
            const deltaRow = toRow - fromRow;
            const deltaCol = toCol - fromCol;
            
            if (deltaRow !== 0 && deltaCol !== 0 && Math.abs(deltaRow) !== Math.abs(deltaCol)) {
                return; // Not straight line or diagonal
            }
            
            // Check path is clear
            const stepRow = deltaRow === 0 ? 0 : deltaRow / Math.abs(deltaRow);
            const stepCol = deltaCol === 0 ? 0 : deltaCol / Math.abs(deltaCol);
            
            let currentRow = fromRow + stepRow;
            let currentCol = fromCol + stepCol;
            
            while (currentRow !== toRow || currentCol !== toCol) {
                const pathCellId = `${String.fromCharCode(64 + currentCol)}${currentRow}`;
                if (gameState.board[pathCellId] || terrainSquares.includes(pathCellId)) {
                    return; // Path blocked
                }
                currentRow += stepRow;
                currentCol += stepCol;
            }
            
            // Deal 1 damage
            target.health -= 1;
            
            if (target.health <= 0) {
                delete gameState.board[cellId];
                gameState.score[gameState.currentPlayer]++;
            }
            
            gameState.hasActed = true;
            clearSelection();
            updateBoard();
            updateUI();
            checkWinConditions();
        }

        // Spell system
        function openSpellModal() {
            const figure = gameState.board[gameState.selectedFigure];
            if (!figure || !isSpellcaster(figure.type)) return;
            
            const spellGrid = document.getElementById('spellGrid');
            spellGrid.innerHTML = '';
            
            const spells = getSpellsForCharacter(figure.type);
            
            spells.forEach(spell => {
                const spellCard = document.createElement('div');
                spellCard.className = 'spell-card';
                spellCard.onclick = () => selectSpell(spell.name);
                
                spellCard.innerHTML = `
                    <h4>${spell.name}</h4>
                    <p>${spell.description}</p>
                `;
                
                spellGrid.appendChild(spellCard);
            });
            
            document.getElementById('spellModal').style.display = 'flex';
        }

        function getSpellsForCharacter(type) {
            const spells = {
                'Black Mage': [
                    {
                        name: 'Magic Bomb',
                        description: 'Place bomb within reach. All figures in that space and adjacent spaces lose 2 life. Once per game.',
                        canUse: () => !gameState.usedSpells?.includes('Magic Bomb')
                    },
                    {
                        name: 'Curse',
                        description: 'Lose X life. One enemy within reach loses X+1 life.',
                        canUse: () => true
                    },
                    {
                        name: 'Animate Dead',
                        description: 'Lose 1 life. Resurrect one dead figure in your start zone with 2 life.',
                        canUse: () => true
                    }
                ],
                'White Mage': [
                    {
                        name: 'Convert',
                        description: 'Take control of an enemy figure with 2 or less life within reach.',
                        canUse: () => true
                    },
                    {
                        name: 'Heal',
                        description: 'One figure within reach gains up to 3 life (max starting life).',
                        canUse: () => true
                    },
                    {
                        name: 'Conjure Containment',
                        description: 'One enemy within reach cannot move, attack or use special actions for 2 turns.',
                        canUse: () => true
                    }
                ]
            };
            
            return spells[type] || [];
        }

        function selectSpell(spellName) {
            gameState.selectedAction = `spell_${spellName}`;
            closeSpellModal();
            
            switch (spellName) {
                case 'Magic Bomb':
                    highlightSpellRange(2);
                    break;
                case 'Curse':
                    highlightEnemiesInRange(2);
                    break;
                case 'Animate Dead':
                    handleAnimateDead();
                    break;
                case 'Convert':
                    highlightConvertTargets();
                    break;
                case 'Heal':
                    highlightHealTargets();
                    break;
                case 'Conjure Containment':
                    highlightEnemiesInRange(2);
                    break;
            }
        }

        function highlightSpellRange(reach) {
            const [fromCol, fromRow] = parseCell(gameState.selectedFigure);
            
            for (let row = 1; row <= 8; row++) {
                for (let col = 1; col <= 8; col++) {
                    const distance = Math.abs(row - fromRow) + Math.abs(col - fromCol);
                    if (distance <= reach) {
                        const cellId = `${String.fromCharCode(64 + col)}${row}`;
                        document.getElementById(cellId).classList.add('highlighted');
                    }
                }
            }
        }

        function highlightEnemiesInRange(reach) {
            const [fromCol, fromRow] = parseCell(gameState.selectedFigure);
            
            for (let row = 1; row <= 8; row++) {
                for (let col = 1; col <= 8; col++) {
                    const cellId = `${String.fromCharCode(64 + col)}${row}`;
                    const target = gameState.board[cellId];
                    const distance = Math.abs(row - fromRow) + Math.abs(col - fromCol);
                    
                    if (target && target.player !== gameState.currentPlayer && distance <= reach) {
                        document.getElementById(cellId).classList.add('attack-range');
                    }
                }
            }
        }

        function highlightConvertTargets() {
            const [fromCol, fromRow] = parseCell(gameState.selectedFigure);
            
            for (let row = 1; row <= 8; row++) {
                for (let col = 1; col <= 8; col++) {
                    const cellId = `${String.fromCharCode(64 + col)}${row}`;
                    const target = gameState.board[cellId];
                    const distance = Math.abs(row - fromRow) + Math.abs(col - fromCol);
                    
                    if (target && target.player !== gameState.currentPlayer && target.health <= 2 && distance <= 2) {
                        document.getElementById(cellId).classList.add('attack-range');
                    }
                }
            }
        }

        function highlightHealTargets() {
            const [fromCol, fromRow] = parseCell(gameState.selectedFigure);
            
            for (let row = 1; row <= 8; row++) {
                for (let col = 1; col <= 8; col++) {
                    const cellId = `${String.fromCharCode(64 + col)}${row}`;
                    const target = gameState.board[cellId];
                    const distance = Math.abs(row - fromRow) + Math.abs(col - fromCol);
                    
                    if (target && target.player === gameState.currentPlayer && distance <= 2) {
                        document.getElementById(cellId).classList.add('highlighted');
                    }
                }
            }
        }

        function handleSpellTarget(cellId) {
            const spellName = gameState.selectedAction.replace('spell_', '');
            
            switch (spellName) {
                case 'Magic Bomb':
                    handleMagicBomb(cellId);
                    break;
                case 'Curse':
                    handleCurse(cellId);
                    break;
                case 'Convert':
                    handleConvert(cellId);
                    break;
                case 'Heal':
                    handleHeal(cellId);
                    break;
                case 'Conjure Containment':
                    handleContainment(cellId);
                    break;
            }
        }

        function handleMagicBomb(cellId) {
            if (!gameState.usedSpells) gameState.usedSpells = [];
            if (gameState.usedSpells.includes('Magic Bomb')) return;
            
            const caster = gameState.board[gameState.selectedFigure];
            const [fromCol, fromRow] = parseCell(gameState.selectedFigure);
            const [toCol, toRow] = parseCell(cellId);
            const distance = Math.abs(toRow - fromRow) + Math.abs(toCol - fromCol);
            
            if (distance <= 2) {
                gameState.usedSpells.push('Magic Bomb');
                
                // Damage all figures in target cell and adjacent cells
                for (let row = toRow - 1; row <= toRow + 1; row++) {
                    for (let col = toCol - 1; col <= toCol + 1; col++) {
                        if (row >= 1 && row <= 8 && col >= 1 && col <= 8) {
                            const targetCell = `${String.fromCharCode(64 + col)}${row}`;
                            const target = gameState.board[targetCell];
                            
                            if (target) {
                                target.health -= 2;
                                if (target.health <= 0) {
                                    delete gameState.board[targetCell];
                                    if (target.player !== gameState.currentPlayer) {
                                        gameState.score[gameState.currentPlayer]++;
                                    }
                                }
                            }
                        }
                    }
                }
                
                gameState.hasActed = true;
                clearSelection();
                updateBoard();
                updateUI();
                checkWinConditions();
            }
        }

        function handleCurse(cellId) {
            const target = gameState.board[cellId];
            const caster = gameState.board[gameState.selectedFigure];
            
            if (!target || target.player === gameState.currentPlayer) return;
            
            const [fromCol, fromRow] = parseCell(gameState.selectedFigure);
            const [toCol, toRow] = parseCell(cellId);
            const distance = Math.abs(toRow - fromRow) + Math.abs(toCol - fromCol);
            
            if (distance <= 2) {
                const damage = parseInt(prompt('How much life do you want to lose? (X)') || '0');
                if (damage > 0 && damage <= caster.health) {
                    caster.health -= damage;
                    target.health -= (damage + 1);
                    
                    if (caster.health <= 0) {
                        delete gameState.board[gameState.selectedFigure];
                    }
                    
                    if (target.health <= 0) {
                        delete gameState.board[cellId];
                        gameState.score[gameState.currentPlayer]++;
                    }
                    
                    gameState.hasActed = true;
                    clearSelection();
                    updateBoard();
                    updateUI();
                    checkWinConditions();
                }
            }
        }

        function handleAnimateDead() {
            const caster = gameState.board[gameState.selectedFigure];
            caster.health -= 1;
            
            if (caster.health <= 0) {
                delete gameState.board[gameState.selectedFigure];
            }
            
            // Show available dead characters
            const deadCharacters = ['Knight', 'Barbarian', 'Arbalist', 'Black Mage', 'White Mage']
                .filter(type => !Object.values(gameState.board).some(fig => fig.type === type && fig.player === gameState.currentPlayer));
            
            if (deadCharacters.length > 0) {
                const choice = prompt(`Choose character to resurrect: ${deadCharacters.join(', ')}`);
                if (deadCharacters.includes(choice)) {
                    // Find empty spot in start zone
                    const startZone = deploymentZones[gameState.currentPlayer];
                    const emptySpot = startZone.find(cellId => !gameState.board[cellId]);
                    
                    if (emptySpot) {
                        gameState.board[emptySpot] = {
                            type: choice,
                            player: gameState.currentPlayer,
                            health: 2,
                            maxHealth: characters[choice].health,
                            id: `${gameState.currentPlayer}_${choice}_revived`
                        };
                    }
                }
            }
            
            gameState.hasActed = true;
            clearSelection();
            updateBoard();
            updateUI();
        }

        function handleConvert(cellId) {
            const target = gameState.board[cellId];
            const caster = gameState.board[gameState.selectedFigure];
            
            if (!target || target.player === gameState.currentPlayer || target.health > 2) return;
            
            const [fromCol, fromRow] = parseCell(gameState.selectedFigure);
            const [toCol, toRow] = parseCell(cellId);
            const distance = Math.abs(toRow - fromRow) + Math.abs(toCol - fromCol);
            
            if (distance <= 2) {
                target.player = gameState.currentPlayer;
                target.id = `${gameState.currentPlayer}_${target.type}_converted`;
                
                gameState.hasActed = true;
                clearSelection();
                updateBoard();
                updateUI();
            }
        }

        function handleHeal(cellId) {
            const target = gameState.board[cellId];
            const caster = gameState.board[gameState.selectedFigure];
            
            if (!target || target.player !== gameState.currentPlayer) return;
            
            const [fromCol, fromRow] = parseCell(gameState.selectedFigure);
            const [toCol, toRow] = parseCell(cellId);
            const distance = Math.abs(toRow - fromRow) + Math.abs(toCol - fromCol);
            
            if (distance <= 2) {
                const healing = Math.min(3, target.maxHealth - target.health);
                target.health += healing;
                
                gameState.hasActed = true;
                clearSelection();
                updateBoard();
                updateUI();
            }
        }

        function handleContainment(cellId) {
            const target = gameState.board[cellId];
            const caster = gameState.board[gameState.selectedFigure];
            
            if (!target || target.player === gameState.currentPlayer) return;
            
            const [fromCol, fromRow] = parseCell(gameState.selectedFigure);
            const [toCol, toRow] = parseCell(cellId);
            const distance = Math.abs(toRow - fromRow) + Math.abs(toCol - fromCol);
            
            if (distance <= 2) {
                gameState.statusEffects.push({
                    type: 'contained',
                    targetId: target.id,
                    cellId: cellId,
                    turnsLeft: 2
                });
                
                gameState.hasActed = true;
                clearSelection();
                updateBoard();
                updateUI();
            }
        }

        function closeSpellModal() { document.getElementById('spellModal').style.display = 'none'; }

        // End turn logic
        function endTurn() {
            // Update status effects
            gameState.statusEffects = gameState.statusEffects.filter(effect => { effect.turnsLeft--; return effect.turnsLeft > 0; });
            
            // Switch players
            gameState.currentPlayer = gameState.currentPlayer === 'A' ? 'B' : 'A';
            gameState.turnCount++;
            gameState.hasMoved = false;
            gameState.hasActed = false;
            
            clearSelection();
            updateUI();
        }

        // Utility functions
        function parseCell(cellId) { const col = cellId.charCodeAt(0) - 64; const row = parseInt(cellId.slice(1)); return [col, row]; }
        function hasLivingFigures(player) { return Object.values(gameState.board).some(fig => fig.player === player); }
        function checkWinConditions() { if (gameState.score.A >= 4) { endGame('A'); } else if (gameState.score.B >= 4) { endGame('B'); } else if (!hasLivingFigures('A')) { endGame('B'); } else if (!hasLivingFigures('B')) { endGame('A'); } }
        function endGame(winner) { gameState.phase = 'ended'; alert(`Player ${winner} wins!`); }

        function updateBoard() {
            // Clear all figures
            document.querySelectorAll('.figure').forEach(fig => fig.remove());
            
            // Place all figures
            Object.entries(gameState.board).forEach(([cellId, figure]) => {
                const cell = document.getElementById(cellId);
                const figureDiv = document.createElement('div');
                figureDiv.className = `figure player-${figure.player.toLowerCase()}`;
                
                const char = characters[figure.type];
                figureDiv.innerHTML = `
                    ${char.symbol}
                    <div class="health">${figure.health}</div>
                `;
                
                cell.appendChild(figureDiv);
            });
        }

        function updateUI() {
            // Update turn indicator
            const turnIndicator = document.getElementById('turnIndicator');
            turnIndicator.textContent = `Player ${gameState.currentPlayer}'s Turn`;
            turnIndicator.className = `turn-indicator turn-player-${gameState.currentPlayer.toLowerCase()}`;
            
            // Update scores
            document.getElementById('scoreA').textContent = gameState.score.A;
            document.getElementById('scoreB').textContent = gameState.score.B;
            document.getElementById('turnCounter').textContent = gameState.turnCount;
            
            // Update status effects
            updateStatusEffects();
            
            updateBoard();
        }

        function updateStatusEffects() {
            const statusDiv = document.getElementById('statusEffects');
            const effectsList = document.getElementById('effectsList');
            
            if (gameState.statusEffects.length > 0) {
                statusDiv.style.display = 'block';
                effectsList.innerHTML = gameState.statusEffects.map(effect => {
                    const figure = gameState.board[effect.cellId];
                    return `${figure?.type || 'Unknown'} is ${effect.type} for ${effect.turnsLeft} more turns`;
                }).join('<br>');
            } else {
                statusDiv.style.display = 'none';
            }
        }

        // Event listeners
        document.getElementById('moveBtn').onclick = startMove;
        document.getElementById('attackBtn').onclick = startAttack;
        document.getElementById('specialBtn').onclick = startSpecialAction;
        document.getElementById('spellBtn').onclick = openSpellModal;
        document.getElementById('endTurnBtn').onclick = endTurn;

        // Initialize the game
        initGame();
    </script>
</body>
</html>
